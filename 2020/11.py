import math
INPUT = '''00009000009000000000000000090900000090000990900000000900000090000990000000000000000000000000000000
00000000000000000000000000090009000000000909900000000900000090000000000000000000000900000000000000
00000000009000000000009000090000000090000000000000000000000090000090090000900900000000000000000000
00090000000000090000900000000009009090000000900000000900000090000090000000900000000900000900000000
00000000009000000000000000090000900090000900000000000900000000000090000000900000000900000000000000
00000000009000000000900000000000000090000000000000000000000090000000009000000000000900000000000000
99909900900900099990999999099099999099999099990900999990099090999009099900990909990900999099009909
00000000000000000090900000090000000090000090900000000000000090000090000000000900000900000000900000
00000000090000000000900000000000000090000000900000000000000090000090000000900000000900000000000009
00000000000000000000000000000000000090000000000000000900000000000090000000900000000900000000000000
00000000000000000000000000090900009090000090900000000900000000000090000000900000000900000900000000
00000009909000000009900090090000009090000000900000000900000090000090090000900000000900009000000000
99909909090999999099990909909990909909099900900999909990999999990909000999909909909990909909900999
00000000009000000000000000090900000090000000900000000000000090000090000000000009090000000000000000
00000000000000000000900009090000000000000009900000000900000090000090000000000000000900000000000000
00090009009000000000900000990000000090000000000000009900000000000090000000900000000900090000000000
90000000009009000000900090000000000000000000900000000000000090000090000000900000000900900000000000
00000900000000000000900000090000000090000000000000000000000090000090000000900000000000000000000000
90000000000000000000909000090000000090000000000000000000990090000000000000900000000000000000000000
09999009999909999990009999990900099099990909999099990090900900999999990099990909099000099999990999
00000009000000000000000000000000000000000000009000000000000090000090009000900000000900000000000000
90099009009000000000900900000000000090000000900000900000000090000000900000000000000000000000000000
00090000000000000000900000000000000000000000900000900900000090000090000000909009000000000000000000
00000000009900000000900009090009000000000000900000000900000090000990000000000990000900000000000000
00090000009000000000900000090000000990000000990000000900000090000090000000900000000000000000000000
90000000000000000000900000090090000090000000000000000900000000000000000000000000000000000000000000
00000000000000000000900900090000000090000000900000000990009090000090000000900000099900000000000000
00090000009000000000000000090000000090000000000000000000000090000090000000900000000900000000090000
00009000009990000000000090090000000090000000900000000000000990000090000000990000000900000000000000
99099900099999999009999099999099999099099099999090900999099999900000909099999999999090099999009990
00000000000000000000900000090000000000000000900000000900000000000090000000900000000900000000000000
00000000009090009000900000090000000090000090000000000900000000000090000000000000000900000009000000
00000000000000000000000000000000000090000000900000000900000090000090000000900000000900000000009000
00000000000000009000000000090000000000000900900900000000000090000090000000000009009000900000000000
00000000009000000000000000090000000999000000000000000900000090000090000000900000000900000000000900
00000009009000000000900000000000000090000000990000000900000090000090000000900000000900000000000000
99990990909009900099099990099909099009099999909990009090909999909999999099999900999990990909900999
00000000009000000000900000090000000090000009000000000000000000000090000000900000009000000000000090
00000000009000000000900009090009000090000000900000000000000090000090000000000000000900000000000000
00000000000009000000900000000000000999000000900000000000000000000090000000000000000900000000000000
00000000009000000000000900000000099000000000000000000900000009000090000000900000000900090000000000
00000000009090000000900000000000000000000000900009000900000090000000000000000000000900090000000000
00900000009000000000900000090000000090000000090000000900090090000090000000900000000900000000000000
99009000999000999990909099999909999990999999990900999999000990099099090009900990090999990900999909
00000000009009000000000000000000000000000000000000000900000000000000000000900000000990000900000000
00000000009000000000000000090000000090000000000000900900000090900000000090900000900909000000000000
00000000009000000000900000000900000090000000000000000900000090000090000000900000000900000000000000
00000000090000000000000000090000000000000000900000000000009000000090000000900900000900000000000900
00000000000000000000900000000900000000000000000009000000000090000090009000900000900900000000000000
09909900990009990999999099999099900990990999990909990099999909090009099099990999909990909999999900
00000000009000000000000000000009000090000000000000000000000000000000000000900000009900000000000000
00000090009000000000900000000000000090900900000000000000000090000000000000000000000900000900000000
09000000009000000000000000090000000090000000000000000900009090000090000000000000000900000000000000
00000000009000900900900000000090090090000000000000000900000000000000000000900000900900000000000000
00900000000000000900900000000000000990000000000900090990000090000099000000900000000000000000000000
00000000000000900000000000090000000090009000000000000900000090000090000000990000000900000000000000
00000000009000900000900900000000000090000000900000000900000090000090000000900090090900000009000909
00000000000000000000900009000000000090009000900000000900000090000000000000000090900900000000009000
99099990999909999099999999099909999099009090990900009090009990999099009909990999909999099999990909
00000000009900090000000000090000000090009000990000000900000090000090000000000000009900990000000000
00000000009000000000900000000000000090000000900900000900000090000000000009900000000000000000000000
00000000090000000000000000099000000090000000000000000900000090000090000000000000000900009000000000
00000000009000000000900000099000000099000000900900000000000090000090000000900000000000000000000090
09000000009000000000900900090000000000000009900000000000000090000090000000900000000900000000000000
00000000009900090000000000000000000090000009000000000900000990000090000000900000000000000000000000
09999909900099999009099099009999000009009909999999099900999990099909999999999909999909099099999090
00000000009000900000900000090000000090000000900000000090000990009000000000900000000000009000000000
00000000009900000900900000090000000000000000900000000900000090000000000000900000000900000000000000
00000000009000000000900000090000000090000000900000000900009090009000000000900000000900000000000000
00000000009000000000000000090000000090000000900000000900000090000090000000900009009000000000000000
00000900009000000090000000090000000090000000000000009000000090000990000000900000000900000000000000
00000000000000000000990000090000000000000000000000000900000090000090000009900000000900000000000000
99999999000000900909909990999000999909999999000099090090990909000999099909999999099099999090909900
00000000009000000000000000090000000000000000000000000900900099000090000000900000000000000000000000
00000000009000000000900000090000000000000009900000000900000000000000000000000000000900090000000000
09000009000000000000900000090000000000090000900090000000000090000000000000900000000900000900000000
00000090009000000000000090000000000090000000900000000900000000000090009090900000000900000000000000
00090000009000000000000000090000000090000000000000000900000000000000000000000000000000000000000000
00000000000000000000090000090000000900000900900000000000000000000090000000990000000900000000000000
99009909999099999990999909999009990909909999999990099099009099990009090009990999990099999009009999
00000000009000000900900000000990000090000000000000000900000090900000000000900000000900000000009000
09000000000000900000000000090000000000000000900000900900000090000090000000900000900000000009000000
00000000009000000000900090090000000090900000000000000000000090900090000000900000000900000000000009
00000000000000000090000000090000000000000000900000009000000000000000000000000000000000009000000000
00000900009000000000900000090000900099000000900000000000000090000090000000000900000900000000000000
00000000000000000000900000090000000000000090000000000900000090000090000000900000000900000000090000
00000000000000000000000009000000000090900000000000000900000090000090000000000000000900900000000000
90909999099999999099990099909990999099099999999999990090099090909990099999990009999999000909090990
00000000009000000000000000090000090090000000000000090900000990000090000000900000000900009000000000
00000000000000000000900000000000000090000000000000000090000000000000900000900000000900000090000000
00000000009900000000900000099000000090000000000000000900000090000090000000900000000090000000000000
00000000009090000000900000000000000900000000900090000900000000090000000000000000000900000900000000
00000900000000000000900000090000000090000000000000090900000090000090000000900000000909000000000000'''

TEST = '''0900900900
0000000900
0909099099
0000900900
0900900900
0900000900
9909099999
0000000000
0900000090
0900000900'''

ROUND1 = {
    0: '''L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL
''',
    1: '''#.##.##.##
#######.##
#.#.#..#..
####.##.##
#.##.##.##
#.#####.##
..#.#.....
##########
#.######.#
#.#####.##
''',
    2: '''#.LL.L#.##
#LLLLLL.L#
L.L.L..L..
#LLL.LL.L#
#.LL.LL.LL
#.LLLL#.##
..L.L.....
#LLLLLLLL#
#.LLLLLL.L
#.#LLLL.##
''',
    3: '''#.##.L#.##
#L###LL.L#
L.#.#..#..
#L##.##.L#
#.##.LL.LL
#.###L#.##
..#.#.....
#L######L#
#.LL###L.L
#.#L###.##
''',
    4: '''#.#L.L#.##
#LLL#LL.L#
L.L.L..#..
#LLL.##.L#
#.LL.LL.LL
#.LL#L#.##
..L.L.....
#L#LLLL#L#
#.LLLLLL.L
#.#L#L#.##
''',
    5:'''#.#L.L#.##
#LLL#LL.L#
L.#.L..#..
#L##.##.L#
#.#L.LL.LL
#.#L#L#.##
..L.L.....
#L#L##L#L#
#.LLLLLL.L
#.#L#L#.##
'''
} 

TEST_RESULT = '''1910901911
1000100901
0919099199
1011911901
1910900900
1910101911
9909099999
1010110101
1900000090
1910101911'''

ROUND2 = {
0: '''L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL''',
1: '''#.##.##.##
#######.##
#.#.#..#..
####.##.##
#.##.##.##
#.#####.##
..#.#.....
##########
#.######.#
#.#####.##''',
2: '''#.LL.LL.L#
#LLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLL#
#.LLLLLL.L
#.LLLLL.L#''',
3: '''#.L#.##.L#
#L#####.LL
L.#.#..#..
##L#.##.##
#.##.#L.##
#.#####.#L
..#.#.....
LLL####LL#
#.L#####.L
#.L####.L#''',
4: '''#.L#.L#.L#
#LLLLLL.LL
L.L.L..#..
##LL.LL.L#
L.LL.LL.L#
#.LLLLL.LL
..L.L.....
LLLLLLLLL#
#.LLLLL#.L
#.L#LL#.L#''',
5: '''#.L#.L#.L#
#LLLLLL.LL
L.L.L..#..
##L#.#L.L#
L.L#.#L.L#
#.L####.LL
..#.#.....
LLL###LLL#
#.LLLLL#.L
#.L#LL#.L#''',
6: '''#.L#.L#.L#
#LLLLLL.LL
L.L.L..#..
##L#.#L.L#
L.L#.LL.L#
#.LLLL#.LL
..#.L.....
LLL###LLL#
#.LLLLL#.L
#.L#LL#.L#''',
7: '''#.L#.L#.L#
#LLLLLL.LL
L.L.L..#..
##L#.#L.L#
L.L#.LL.L#
#.LLLL#.LL
..#.L.....
LLL###LLL#
#.LLLLL#.L
#.L#LL#.L#''',
} # Round 7 is the same as Round 6.

PROCESSED_ROUND_VALUES = {

}

def graph(values):
    rows = values.split('\n')
    grid = []
    row_count = len(rows)
    row_length = len(rows[0])
    for row in range(row_count):
        grid.append([])
        for column in range(row_length):
            grid[row].append(rows[row][column])
    return grid

def filled_adjacent1(grid, row, rows, column, columns):
    adj_rows = [row]
    adj_columns = [column]
    if row > 0:
        adj_rows.append(row - 1)
    if column > 0:
        adj_columns.append(column - 1)
    if row < rows - 1:
        adj_rows.append(row + 1)
    if column < columns - 1:
        adj_columns.append(column + 1)

    count = 0
    for adj_row in adj_rows:
        for adj_column in adj_columns:
            # Ignore seat in question; count all other fills
            if adj_row != row or adj_column != column:
                value = grid[adj_row][adj_column]
                if value == '1':
                    count += 1
    return count

def filled_adjacent2(grid, row, rows, column, columns):
    # Check 8 directions.
    count = 0
    # Horizontal, vertical
    for r in range(0, row):
        count += 1 if grid[r][column] == '1' else 0
        break
    for r in range(row + 1, rows):
        count += 1 if grid[r][column] == '1' else 0
        break
    for c in range(0, column):
        count += 1 if grid[row][c] == '1' else 0
        break
    for c in range(column + 1, columns):
        count += 1 if grid[row][c] == '1' else 0
        break

    # Diagonals depend on minimum steps to the edge
    for i in range(1, min(row, column)):
        count += 1 if grid[row - i][column - i] == '1' else 0
        break
    for i in range(1, min(row, columns - column)):
        count += 1 if grid[row - i][column + i] == '1' else 0
        break
    for i in range(1, min(rows - row, column)):
        count += 1 if grid[row + i][column - i] == '1' else 0
        break
    for i in range(1, min(rows - row, columns - column)):
        count += 1 if grid[row + i][column + i] == '1' else 0
        break
    return count


def output_results(round, grid, rows, columns, outputs='L#.', confirm=True):
    if confirm:
        print(produce_output(round, grid, rows, columns, outputs))

def produce_output(round, grid, rows, columns, outputs='L#.', confirm=False):
    encoding={'0':0,'1':1,'9':2}
    chars = []
    for row in range(rows):
        for column in range(columns):
            chars.append(outputs[encoding[grid[row][column]]]) # One liner because I don't expect to look at it again
        chars.append('\n')
    return ''.join(chars).strip()


def solve(cases, adjacency_method, visibile_limits, confirm=False, tests=ROUND1, nickname="TESTS"):
    round = 0
    PROCESSED_ROUND_VALUES[nickname] = {
        round : graph(cases.strip())
    }
    
    rows = len(PROCESSED_ROUND_VALUES[nickname][round])
    columns = len(PROCESSED_ROUND_VALUES[nickname][round][0])

    # Provide variables which will be set for round 1
    fills = None
    empties = None

    last_output = ''
    output = cases.strip()
    while last_output != output: #If any seat changes occured, continue
        last_output = produce_output(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns, '019')
        if last_output != output:
            print("ERROR: produce_output produces inconsistent results in round", round)
            print(last_output)
            print()
            print(output)
            exit()

        round += 1
        PROCESSED_ROUND_VALUES[nickname][round] = graph(last_output)
        results = list_changes(rows, columns, PROCESSED_ROUND_VALUES[nickname][round], adjacency_method=adjacency_method, visibile_limits=visibile_limits, confirm=confirm)
        fills = [r for r in results if results[r] > 0]
        empties = [r for r in results if results[r] < 0]
        
        empty_fills_count = 0
        fill_empties_count = 0
        for fill in fills:
            if fill in empties:
                # This is not good. filled_adjacent has a bug.
                empty_fills_count += 1
            PROCESSED_ROUND_VALUES[nickname][round][fill[0]][fill[1]] = '1'
        for empty in empties:
            if empty in fills:
                # This is not good. filled_adjacent has a bug.
                fill_empties_count += 1
            PROCESSED_ROUND_VALUES[nickname][round][empty[0]][empty[1]] = '0'
        output = produce_output(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns, '019')

        # Parentheses for grouping logical bug detection
        if (output == last_output and (fills or empties)) or (empty_fills_count or fill_empties_count):
            print("wat. Error in round", round)
            if output == last_output and (fills or empties):
                print("Seriously, output should not be constant if seat swaps occurred. Are all fills also empties?")
            if empty_fills_count or fill_empties_count:
                print("Seriously, the 'elif' was intended to prevent coordinates from filling and emptying.")
                e_in_f=[e for e in empties if e in fills]
                print("Empties in fill:", len(e_in_f), 'of', len(empties))
                print(e_in_f)
                f_in_e=[f for f in fills if f in empties]
                print("Fills in empty:", len(f_in_e), 'of', len(fills))
                print(f_in_e)
            exit()

        if confirm:
            if round not in tests:
                print("ERROR: Aborting because proceeded too long")
                break
            expectation = tests[round].strip()
            print_output = produce_output(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns)
            if expectation != print_output.strip():
                print('ERROR: Round', round, 'failed with expectation')
                print(expectation)
                print('and output')
                print(print_output)
                for index, char in enumerate(expectation):
                    if char != print_output[index]:
                        row = math.floor(index / (rows + 1))
                        column = index % (rows + 1)
                        print('First error at', row, column, 'expected', char, 'but got', print_output[index])
                        print('based on adjacents', adjacency_method(PROCESSED_ROUND_VALUES[nickname][round], row, rows, column, columns))
                        break
                print('fills', fills)
                print('empties', empties)
                exit()
    
    count = 0
    for row in PROCESSED_ROUND_VALUES[nickname][round]:
        for value in row:
            if value == '1':
                count += 1

    confirm_print(confirm)
    confirm_print("Finished", confirm)
    confirm_print('result at 1,3:', PROCESSED_ROUND_VALUES[nickname][round][1][3], 'with adjacents:', adjacency_method(PROCESSED_ROUND_VALUES[nickname][round],1,rows,3,columns), confirm)
    output_results(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns)
    output_results(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns, '019')
    return count

def confirm_print(*args):
    if args and args[-1]:
        for arg in args[:-1]:
            print(arg, end=' ')
        print()

def list_changes(rows, columns, current, adjacency_method=filled_adjacent1, visibile_limits=(-1, -1), confirm=False):
    results = {}
    for row in range(rows):
        for column in range(columns):
            cell = current[row][column]
            key = (row, column)
            if cell == '9':
                continue
            adjacents = adjacency_method(current, row, rows, column, columns)
            confirm_print(cell,'at',row, column, 'adjacents', adjacents, confirm)
            if cell == '1' and adjacents >= visibile_limits[1]:
                confirm_print('Leave seat', row, column, confirm)
                if key in results:
                    print("ERROR: key already filled", key, cell)
                    exit()
                results[key] = -1
            elif cell == '0' and adjacents == visibile_limits[0]:
                confirm_print('Fill  seat', row, column, confirm)
                if key in results:
                    print("ERROR: key already filled", key, cell)
                    exit()
                results[key] = 1
    return results

if __name__ == '__main__':
    # # Why did I literally test if a method existed? Probably meant to run the method... which is recursive and references itself with the wrong function definition. Delerium.
    # if not confirm_adjacents():
    #     confirm_print('CRITICAL: could not process adjacents', True)
    test_results = solve(TEST, filled_adjacent1, (0, 4), tests=ROUND1, confirm=True, nickname='test1')
    if test_results != len(TEST_RESULT.split('1')) - 1:
        confirm_print(test_results, 'should be', len(TEST_RESULT.split('1')) -1, True)
        exit()
    confirm_print('results', test_results, True)

    results = solve(INPUT, filled_adjacent1, (0, 4), nickname='part1')
    confirm_print(results, True)

    test_results = solve(TEST, filled_adjacent2, (0, 5), tests=ROUND2, confirm=True, nickname='test2')
    if test_results != len(TEST_RESULT.split('1')) - 1:
        confirm_print(test_results, 'should be', len(TEST_RESULT.split('1')) -1, True)
        exit()
    confirm_print('results', test_results, True)

    results = solve(INPUT, filled_adjacent2, (0, 5), nickname='part2')
    confirm_print(results, True)
