import math
INPUT = '''00009000009000000000000000090900000090000990900000000900000090000990000000000000000000000000000000
00000000000000000000000000090009000000000909900000000900000090000000000000000000000900000000000000
00000000009000000000009000090000000090000000000000000000000090000090090000900900000000000000000000
00090000000000090000900000000009009090000000900000000900000090000090000000900000000900000900000000
00000000009000000000000000090000900090000900000000000900000000000090000000900000000900000000000000
00000000009000000000900000000000000090000000000000000000000090000000009000000000000900000000000000
99909900900900099990999999099099999099999099990900999990099090999009099900990909990900999099009909
00000000000000000090900000090000000090000090900000000000000090000090000000000900000900000000900000
00000000090000000000900000000000000090000000900000000000000090000090000000900000000900000000000009
00000000000000000000000000000000000090000000000000000900000000000090000000900000000900000000000000
00000000000000000000000000090900009090000090900000000900000000000090000000900000000900000900000000
00000009909000000009900090090000009090000000900000000900000090000090090000900000000900009000000000
99909909090999999099990909909990909909099900900999909990999999990909000999909909909990909909900999
00000000009000000000000000090900000090000000900000000000000090000090000000000009090000000000000000
00000000000000000000900009090000000000000009900000000900000090000090000000000000000900000000000000
00090009009000000000900000990000000090000000000000009900000000000090000000900000000900090000000000
90000000009009000000900090000000000000000000900000000000000090000090000000900000000900900000000000
00000900000000000000900000090000000090000000000000000000000090000090000000900000000000000000000000
90000000000000000000909000090000000090000000000000000000990090000000000000900000000000000000000000
09999009999909999990009999990900099099990909999099990090900900999999990099990909099000099999990999
00000009000000000000000000000000000000000000009000000000000090000090009000900000000900000000000000
90099009009000000000900900000000000090000000900000900000000090000000900000000000000000000000000000
00090000000000000000900000000000000000000000900000900900000090000090000000909009000000000000000000
00000000009900000000900009090009000000000000900000000900000090000990000000000990000900000000000000
00090000009000000000900000090000000990000000990000000900000090000090000000900000000000000000000000
90000000000000000000900000090090000090000000000000000900000000000000000000000000000000000000000000
00000000000000000000900900090000000090000000900000000990009090000090000000900000099900000000000000
00090000009000000000000000090000000090000000000000000000000090000090000000900000000900000000090000
00009000009990000000000090090000000090000000900000000000000990000090000000990000000900000000000000
99099900099999999009999099999099999099099099999090900999099999900000909099999999999090099999009990
00000000000000000000900000090000000000000000900000000900000000000090000000900000000900000000000000
00000000009090009000900000090000000090000090000000000900000000000090000000000000000900000009000000
00000000000000000000000000000000000090000000900000000900000090000090000000900000000900000000009000
00000000000000009000000000090000000000000900900900000000000090000090000000000009009000900000000000
00000000009000000000000000090000000999000000000000000900000090000090000000900000000900000000000900
00000009009000000000900000000000000090000000990000000900000090000090000000900000000900000000000000
99990990909009900099099990099909099009099999909990009090909999909999999099999900999990990909900999
00000000009000000000900000090000000090000009000000000000000000000090000000900000009000000000000090
00000000009000000000900009090009000090000000900000000000000090000090000000000000000900000000000000
00000000000009000000900000000000000999000000900000000000000000000090000000000000000900000000000000
00000000009000000000000900000000099000000000000000000900000009000090000000900000000900090000000000
00000000009090000000900000000000000000000000900009000900000090000000000000000000000900090000000000
00900000009000000000900000090000000090000000090000000900090090000090000000900000000900000000000000
99009000999000999990909099999909999990999999990900999999000990099099090009900990090999990900999909
00000000009009000000000000000000000000000000000000000900000000000000000000900000000990000900000000
00000000009000000000000000090000000090000000000000900900000090900000000090900000900909000000000000
00000000009000000000900000000900000090000000000000000900000090000090000000900000000900000000000000
00000000090000000000000000090000000000000000900000000000009000000090000000900900000900000000000900
00000000000000000000900000000900000000000000000009000000000090000090009000900000900900000000000000
09909900990009990999999099999099900990990999990909990099999909090009099099990999909990909999999900
00000000009000000000000000000009000090000000000000000000000000000000000000900000009900000000000000
00000090009000000000900000000000000090900900000000000000000090000000000000000000000900000900000000
09000000009000000000000000090000000090000000000000000900009090000090000000000000000900000000000000
00000000009000900900900000000090090090000000000000000900000000000000000000900000900900000000000000
00900000000000000900900000000000000990000000000900090990000090000099000000900000000000000000000000
00000000000000900000000000090000000090009000000000000900000090000090000000990000000900000000000000
00000000009000900000900900000000000090000000900000000900000090000090000000900090090900000009000909
00000000000000000000900009000000000090009000900000000900000090000000000000000090900900000000009000
99099990999909999099999999099909999099009090990900009090009990999099009909990999909999099999990909
00000000009900090000000000090000000090009000990000000900000090000090000000000000009900990000000000
00000000009000000000900000000000000090000000900900000900000090000000000009900000000000000000000000
00000000090000000000000000099000000090000000000000000900000090000090000000000000000900009000000000
00000000009000000000900000099000000099000000900900000000000090000090000000900000000000000000000090
09000000009000000000900900090000000000000009900000000000000090000090000000900000000900000000000000
00000000009900090000000000000000000090000009000000000900000990000090000000900000000000000000000000
09999909900099999009099099009999000009009909999999099900999990099909999999999909999909099099999090
00000000009000900000900000090000000090000000900000000090000990009000000000900000000000009000000000
00000000009900000900900000090000000000000000900000000900000090000000000000900000000900000000000000
00000000009000000000900000090000000090000000900000000900009090009000000000900000000900000000000000
00000000009000000000000000090000000090000000900000000900000090000090000000900009009000000000000000
00000900009000000090000000090000000090000000000000009000000090000990000000900000000900000000000000
00000000000000000000990000090000000000000000000000000900000090000090000009900000000900000000000000
99999999000000900909909990999000999909999999000099090090990909000999099909999999099099999090909900
00000000009000000000000000090000000000000000000000000900900099000090000000900000000000000000000000
00000000009000000000900000090000000000000009900000000900000000000000000000000000000900090000000000
09000009000000000000900000090000000000090000900090000000000090000000000000900000000900000900000000
00000090009000000000000090000000000090000000900000000900000000000090009090900000000900000000000000
00090000009000000000000000090000000090000000000000000900000000000000000000000000000000000000000000
00000000000000000000090000090000000900000900900000000000000000000090000000990000000900000000000000
99009909999099999990999909999009990909909999999990099099009099990009090009990999990099999009009999
00000000009000000900900000000990000090000000000000000900000090900000000000900000000900000000009000
09000000000000900000000000090000000000000000900000900900000090000090000000900000900000000009000000
00000000009000000000900090090000000090900000000000000000000090900090000000900000000900000000000009
00000000000000000090000000090000000000000000900000009000000000000000000000000000000000009000000000
00000900009000000000900000090000900099000000900000000000000090000090000000000900000900000000000000
00000000000000000000900000090000000000000090000000000900000090000090000000900000000900000000090000
00000000000000000000000009000000000090900000000000000900000090000090000000000000000900900000000000
90909999099999999099990099909990999099099999999999990090099090909990099999990009999999000909090990
00000000009000000000000000090000090090000000000000090900000990000090000000900000000900009000000000
00000000000000000000900000000000000090000000000000000090000000000000900000900000000900000090000000
00000000009900000000900000099000000090000000000000000900000090000090000000900000000090000000000000
00000000009090000000900000000000000900000000900090000900000000090000000000000000000900000900000000
00000900000000000000900000090000000090000000000000090900000090000090000000900000000909000000000000'''

TEST = '''0900900900
0000000900
0909099099
0000900900
0900900900
0900000900
9909099999
0000000000
0900000090
0900000900'''

ROUND = {
    0: '''L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL
''',
    1: '''#.##.##.##
#######.##
#.#.#..#..
####.##.##
#.##.##.##
#.#####.##
..#.#.....
##########
#.######.#
#.#####.##
''',
    2: '''#.LL.L#.##
#LLLLLL.L#
L.L.L..L..
#LLL.LL.L#
#.LL.LL.LL
#.LLLL#.##
..L.L.....
#LLLLLLLL#
#.LLLLLL.L
#.#LLLL.##
''',
    3: '''#.##.L#.##
#L###LL.L#
L.#.#..#..
#L##.##.L#
#.##.LL.LL
#.###L#.##
..#.#.....
#L######L#
#.LL###L.L
#.#L###.##
''',
    4: '''#.#L.L#.##
#LLL#LL.L#
L.L.L..#..
#LLL.##.L#
#.LL.LL.LL
#.LL#L#.##
..L.L.....
#L#LLLL#L#
#.LLLLLL.L
#.#L#L#.##
''',
    5:'''#.#L.L#.##
#LLL#LL.L#
L.#.L..#..
#L##.##.L#
#.#L.LL.LL
#.#L#L#.##
..L.L.....
#L#L##L#L#
#.LLLLLL.L
#.#L#L#.##
'''
} 

TEST_RESULT = '''1910901911
1000100901
0919099199
1011911901
1910900900
1910101911
9909099999
1010110101
1900000090
1910101911'''

PROCESSED_ROUND_VALUES = {

}

def graph(values):
    rows = values.split('\n')
    grid = []
    row_count = len(rows)
    row_length = len(rows[0])
    for row in range(row_count):
        grid.append([])
        for column in range(row_length):
            grid[row].append(rows[row][column])
    return grid

def filled_adjacent(grid, row, rows, column, columns):
    adj_rows = [row]
    adj_columns = [column]
    if row > 0:
        adj_rows.append(row - 1)
    if column > 0:
        adj_columns.append(column - 1)
    if row < rows - 1:
        adj_rows.append(row + 1)
    if column < columns - 1:
        adj_columns.append(column + 1)

    count = 0
    for adj_row in adj_rows:
        for adj_column in adj_columns:
            # Ignore seat in question; count all other fills
            if adj_row != row or adj_column != column:
                value = grid[adj_row][adj_column]
                if value == '1':
                    count += 1
    return count

def output_results(round, grid, rows, columns, outputs='L#.', confirm=True):
    if confirm:
        print(produce_output(round, grid, rows, columns, outputs))

def produce_output(round, grid, rows, columns, outputs='L#.', confirm=False):
    encoding={'0':0,'1':1,'9':2}
    chars = []
    for row in range(rows):
        for column in range(columns):
            chars.append(outputs[encoding[grid[row][column]]]) # One liner because I don't expect to look at it again
        chars.append('\n')
    return ''.join(chars).strip()


def solve(cases, confirm=False, nickname="TESTS"):
    round = 0
    PROCESSED_ROUND_VALUES[nickname] = {
        round : graph(cases.strip())
    }
    
    rows = len(PROCESSED_ROUND_VALUES[nickname][round])
    columns = len(PROCESSED_ROUND_VALUES[nickname][round][0])

    # Provide variables which will be set for round 1
    fills = None
    empties = None

    last_output = ''
    output = cases.strip()
    while last_output != output: #If any seat changes occured, continue
        last_output = produce_output(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns, '019')
        if last_output != output:
            print("ERROR: produce_output produces inconsistent results in round", round)
            print(last_output)
            print()
            print(output)
            exit()

        round += 1
        PROCESSED_ROUND_VALUES[nickname][round] = graph(last_output)
        results = list_changes(rows, columns, PROCESSED_ROUND_VALUES[nickname][round], confirm=confirm)
        fills = [r for r in results if results[r] > 0]
        empties = [r for r in results if results[r] < 0]
        
        empty_fills_count = 0
        fill_empties_count = 0
        for fill in fills:
            if fill in empties:
                # This is not good. filled_adjacent has a bug.
                empty_fills_count += 1
            PROCESSED_ROUND_VALUES[nickname][round][fill[0]][fill[1]] = '1'
        for empty in empties:
            if empty in fills:
                # This is not good. filled_adjacent has a bug.
                fill_empties_count += 1
            PROCESSED_ROUND_VALUES[nickname][round][empty[0]][empty[1]] = '0'
        output = produce_output(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns, '019')

        # Parentheses for grouping logical bug detection
        if (output == last_output and (fills or empties)) or (empty_fills_count or fill_empties_count):
            print("wat. Error in round", round)
            if output == last_output and (fills or empties):
                print("Seriously, output should not be constant if seat swaps occurred. Are all fills also empties?")
            if empty_fills_count or fill_empties_count:
                print("Seriously, the 'elif' was intended to prevent coordinates from filling and emptying.")
                e_in_f=[e for e in empties if e in fills]
                print("Empties in fill:", len(e_in_f), 'of', len(empties))
                print(e_in_f)
                f_in_e=[f for f in fills if f in empties]
                print("Fills in empty:", len(f_in_e), 'of', len(fills))
                print(f_in_e)
            exit()

        if confirm:
            if round not in ROUND:
                print("ERROR: Aborting because proceeded too long")
                break
            expectation = ROUND[round].strip()
            print_output = produce_output(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns)
            if expectation != print_output.strip():
                print('ERROR: Round', round, 'failed with expectation')
                print(expectation)
                print('and output')
                print(print_output)
                for index, char in enumerate(expectation):
                    if char != print_output[index]:
                        row = math.floor(index / (rows + 1))
                        column = index % (rows + 1)
                        print('First error at', row, column, 'expected', char, 'but got', print_output[index])
                        print('based on adjacents', filled_adjacent(PROCESSED_ROUND_VALUES[nickname][round], row, rows, column, columns))
                        break
                print('fills', fills)
                print('empties', empties)
                exit()
    
    count = 0
    for row in PROCESSED_ROUND_VALUES[nickname][round]:
        for value in row:
            if value == '1':
                count += 1

    confirm_print(confirm)
    confirm_print("Finished", confirm)
    confirm_print('result at 1,3:', PROCESSED_ROUND_VALUES[nickname][round][1][3], 'with adjacents:', filled_adjacent(PROCESSED_ROUND_VALUES[nickname][round],1,rows,3,columns), confirm)
    output_results(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns)
    output_results(round, PROCESSED_ROUND_VALUES[nickname][round], rows, columns, '019')
    return count

def confirm_print(*args):
    if args and args[-1]:
        for arg in args[:-1]:
            print(arg, end=' ')
        print()

def list_changes(rows, columns, current, fills=[], empties=[], confirm=False):
    results = {}
    for row in range(rows):
        for column in range(columns):
            cell = current[row][column]
            key = (row, column)
            if cell == '9':
                continue
            adjacents = filled_adjacent(current, row, rows, column, columns)
            confirm_print(cell,'at',row, column, 'adjacents', adjacents, confirm)
            if cell == '1' and adjacents >= 4:
                confirm_print('Leave seat', row, column, confirm)
                if key in results:
                    print("ERROR: key already filled", key, cell)
                    exit()
                results[key] = -1
            elif cell == '0' and adjacents == 0:
                confirm_print('Fill  seat', row, column, confirm)
                if key in results:
                    print("ERROR: key already filled", key, cell)
                    exit()
                results[key] = 1
    return results

def solve2(cases):
    return solve(cases)

def confirm_adjacents(confirm=True):
    test = [['1']]
    r0 = confirm_adjacents(test, 0, 1, 0, 1)
    if r0 != 0:
        confirm_print('ERROR A: checked self', r0, confirm)
        return False

    test = [['0','1'],['1','1']]
    r1 = confirm_adjacents(test, 0, 2, 0, 2)
    r2 = confirm_adjacents(test, 0, 2, 1, 2)
    r3 = confirm_adjacents(test, 1, 2, 0, 2)
    r4 = confirm_adjacents(test, 1, 2, 1, 2)
    if r1 != 3:
        confirm_print('ERROR B: not 3', r1, confirm)
        return False
    if r2 != 2:
        confirm_print('ERROR C: not 2', r2, confirm)
        return False
    if r3 != 2:
        confirm_print('ERROR C: not 2', r3, confirm)
        return False
    if r4 != 2:
        confirm_print('ERROR C: not 2', r4, confirm)
        return False

    test = [['9','1','0'],
            ['1','1','1'],
            ['1','1','1']]
    expectations = [[3, 3, 3],
                    [4, 6, 4],
                    [3, 5, 3]]
    for i in range(3):
        for j in range(3):
            result = confirm_adjacents(test, i, 3, j, 3)
            if result != expectations[i][j]:
                confirm_print('ERROR MULTI', i, j, ':', result, 'not', expectations[i][j], confirm)
                return False
    fills, empties = list_changes(3, 3, test)
    expected_empties = [(1,0), (1,1), (1,2), (2,1)]
    for empty in expected_empties:
        if empty not in empties:
            confirm_print('ERROR EMPTY', empty, confirm)
            confirm_print(empties, confirm)
            return False

    round1=ROUND[1]
    fills, empties = list_changes(2, 10, round1)
    expectations = [(0,2),(0,3),(0,5),(0,6)]
    for expectation in expectations:
        if expectation not in empties:
            print('ERROR ROUND1', expectation, empties)
            exit()

    return True

if __name__ == '__main__':
    if not confirm_adjacents:
        confirm_print('CRITICAL: could not process adjacents', True)
    test_results = solve(TEST, confirm=True)
    if test_results != len(TEST_RESULT.split('1')) - 1:
        confirm_print(test_results, 'should be', len(TEST_RESULT.split('1')) -1, True)
        exit()
    confirm_print('results', test_results, True)

    results = solve(INPUT)
    confirm_print(results, True)

    # test_results = solve2(TEST)
    # if test_results != 8:
    
    #     confirm_print(test_results, 'should be 8', confirm=True)
    #     exit()

    # results = solve2(INPUT)
    # confirm_print(results, confirm=True)